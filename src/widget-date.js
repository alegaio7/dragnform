import Widget from "./widget-base.js";
import * as constants from './constants.js';
import WidgetInputBase from "./widget-input-base.js";

class WidgetDate extends WidgetInputBase {
    constructor(fragment) {
        super(constants.WIDGET_TYPE_DATE, fragment);
        this._dateFormat = fragment.dateFormat ?? "yyyy/MM/dd"; 
    }

    get dateFormat() { return this._dateFormat; }
    set dateFormat(value) {
        // just do basic checks. only accept placeholders yyyy, MM, dd and separator "-" or "/"
        if (!value || !value.length === 10)
            return;
        if (!value.includes("yyyy") || !value.includes("MM") || !value.includes("dd") || 
            value.indexOf("yyyy") === -1 || value.indexOf("MM") === -1 || value.indexOf("dd") === -1)
            return;
        if (value.indexOf("-") === -1 && value.indexOf("/") === -1)
            return;
        this._dateFormat = value;
        this.refresh();
    }

    exportJson() {
        var json = super.exportJson();
        var localProps = {
            validations: [
                { type: "required", value: this.required, message: this.valueRequiredValidationMessage },
            ]
        };

        localProps.dateFormat = this._dateFormat;
        localProps.value = this.value ?? null;
        Object.assign(json, localProps);
        return json;
    }
    
    getEditorProperties() {
        var props = super.getEditorProperties();

        props.push(
            { name: "required", type: "boolean", elementId: "chkWidgetPropRequired", value: this.required },
            { name: "valueRequiredValidationMessage", type: "string", elementId: "txtWidgetPropRequiredValidationMessage", value: this.valueRequiredValidationMessage }
        );
        return props;
    }

    async getPropertiesEditorTemplate() {
        var props = await this._getPropertiesEditorTemplateCore("widget-date", "WidgetDatePropertiesEditor");
        var replacements = props.replacements;

        replacements.labelValueRequiredValidationMessage = Strings.WidgetEditor_Common_Widget_ValueRequiredMessage;

        return props;
    }

    refresh() {
        if (!this._el || this._batchUpdating)
            return;
        super.refresh();
        this._updateContols();
    }

    /// <summary>
    /// Generates the markup for the input control used in design and run modes. 
    /// The markup for view mode is generated by the base class.
    /// </summary>
    async render(container, parser) {
        var widgetClass = this.widgetClass ?? "";
        if (this.widgetRenderOptions.renderGrip)
            widgetClass = "has-grip" + (widgetClass ? " " : "") + widgetClass;

        var inputIdDesign = `input_design_${this.id}`;
        var inputIdRun = `input_run_${this.id}`;
        var replacements = {
            colClass: "widget-col-" + this.columns,
            hasName: this.name ? true : false,
            hasTip: this.widgetRenderOptions.renderTips,
            hasValue: this.value ? true : false,
            id: this.id,
            inputClass: this.globalClasses.input ?? "",
            inputIdDesign: inputIdDesign,
            inputIdRun: inputIdRun,
            label: this.label,
            labelClass: this.globalClasses.inputLabel ?? "",
            mark: this.requiredAttributeSettings.mark,
            mode: constants.WIDGET_MODE_DESIGN,
            required: this.required,
            showGrip: this.widgetRenderOptions.renderGrip,
            showRemove: this.widgetRenderOptions.renderRemove,
            showRequiredMarkAfter: this.required && this.requiredAttributeSettings.mark && this.requiredAttributeSettings.position == constants.WIDGET_LABEL_REQUIRED_MARK_POSITION_AFTER,
            showRequiredMarkBefore: this.required && this.requiredAttributeSettings.mark && this.requiredAttributeSettings.position == constants.WIDGET_LABEL_REQUIRED_MARK_POSITION_BEFORE,
            style: this._buildOuterStyleAttribute(),
            type: this.type,
            value: this.value,
            valueControlClass: this.globalClasses.valueControl ?? "",
            widgetClass: widgetClass,
            widgetPropertiesButtonTitle: Strings.WidgetPropertiesButtonTitle,
            widgetRemoveButtonTitle: Strings.WidgetRemoveButtonTitle,
        };

        var html = await super._loadWidgetTemplate("widget-date", replacements);
        super._renderDOM(container, parser, html);
    }

    validate(validationOptions) {
        this.clearError();
        var input = this._el.querySelector(`[data-show-when="run"] input`);
        var r = super._validateInputCtl(input);

        if (validationOptions && validationOptions.showErrors && !r.result)
            this.setError(r);
        return r;
    }

    // *******************************************************************************
    // Private methods
    // *******************************************************************************

    _formatAsDate(value) {
        if (!value)
            return null;
        var y = value.substring(0, 4);
        var m = value.substring(5, 7);
        var d = value.substring(8, 10);

        if (!this._dateFormat)
            this._dateFormat = "yyyy-MM-dd";

        var yyPlaceholder = this._dateFormat.indexOf("yyyy");
        var mmPlaceholder = this._dateFormat.indexOf("MM");
        var ddPlaceholder = this._dateFormat.indexOf("dd");
        var separator = this._dateFormat.indexOf("-") > -1 ? "-" : (this._dateFormat.indexOf("/") > -1 ? "/" : "-");

        // placeholder indexes are only used to determine order, not absolute positioning in formatted string
        var formatted = "";
        var minPlaceholder = Math.min(yyPlaceholder, mmPlaceholder, ddPlaceholder);
        for (var i = 0; i < 3; i++) {
            if (formatted.length > 0)
                formatted += separator;

            if (minPlaceholder === yyPlaceholder) {
                formatted += y;
                yyPlaceholder = Infinity;
            }
            else if (minPlaceholder === mmPlaceholder) {
                formatted += m;
                mmPlaceholder = Infinity;
            }
            else {
                formatted += d
                ddPlaceholder = Infinity
            }

            minPlaceholder = Math.min(yyPlaceholder, mmPlaceholder, ddPlaceholder);
        }

        return formatted;
    }

    _updateContols() {
        super._updateContols();
        // _el can be null if element was not rendered yet
        if (this._el) {
            var viewModeValue = this._el.querySelector(`span[data-part="value"]`);
            if (viewModeValue)
                viewModeValue.innerHTML = this.value ? this._formatAsDate(this.value) : "&nbsp;";   // render nbsp so to keep the height of the element
        }
    }
}

export default WidgetDate;