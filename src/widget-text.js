import Widget from "./widget-base.js";
import * as constants from './constants.js';
import WidgetInputBase from "./widget-input-base.js";

class WidgetText extends WidgetInputBase {
    constructor(fragment) {
        super(constants.WIDGET_TYPE_TEXT, fragment);

        // check validations
        var vals = this.validations;
        if (vals.length) {
            vals.forEach(v => {
                if (v.type === "minLength" || v.type === "maxLength") {
                    let n = parseInt(v.value);
                    if (!(n >= 0)) {
                        if (v.type === "minLength")
                            throw new Error(`Widget ${this.id}: minLength must be greater than or equal to 0.`);
                        else if (v.type === "maxLength")
                            throw new Error(`Widget ${this.id}: minLength must be less than or equal to ${constants.WIDGET_TYPE_TEXT_MAX_LENGTH}`);
                    }

                    if (!(n <= constants.WIDGET_TYPE_TEXT_MAX_LENGTH)) {
                        if (v.type === "minLength")
                            throw new Error(`Widget ${this.id}: minLength must be less than or equal to ${constants.WIDGET_TYPE_TEXT_MAX_LENGTH}`);
                        else if (v.type === "maxLength")
                            throw new Error(`Widget ${this.id}: maxLength must be less than or equal to ${constants.WIDGET_TYPE_TEXT_MAX_LENGTH}`);
                    }
                
                    v.value = n;
                } else if (v.type === "pattern") {
                    let p = Widget.getRegexPattern(v.value);
                    if (!p)
                        throw new Error(`Widget ${this.id}: pattern not found: ${v.value}`);
                    v.pattern = p;
                }
            });
        }
    }

    get minLength() { return this._findValidation("minLength")?.value ?? 0; }
    get minLengthValidationMessage() { return this._findValidation("minLength")?.message ?? ""; }
    get maxLength() { return this._findValidation("maxLength")?.value ?? null; }
    get maxLengthValidationMessage() { return this._findValidation("maxLength")?.message ?? ""; }
    get pattern() { return this._findValidation("pattern")?.pattern ?? ""; }
    get patternValidationMessage() { return this._findValidation("pattern")?.message ?? ""; }

    exportJson() {
        var json = super.exportJson();
        var localProps = {validations: this.validations};
        if (localProps.validations && localProps.validations.length) {
            localProps.validations.forEach(v => {
                if (v.type === "pattern" && v.pattern)
                    delete v.pattern;  // delete object created in .ctor
            });
        }
        localProps.value = this.value ?? null;
        Object.assign(json, localProps);
        return json;
    }
    
    /// <summary>
    /// Generates the markup for the input control used in design and run modes. 
    /// The markup for view mode is generated by the base class.
    /// </summary>
    async render(container, parser) {
        var widgetClass = this.widgetClass ?? "";
        if (this.widgetRenderOptions.renderGrip)
            widgetClass = "has-grip" + (widgetClass ? " " : "") + widgetClass;

        var inputIdDesign = `input_design_${this.id}`;
        var inputIdRun = `input_run_${this.id}`;
        var replacements = {
            colClass: "widget-col-" + this.columns,
            hasMaxLength: (typeof this.maxLength === "number" && this.maxLength >= 0),
            hasMinLength: (typeof this.minLength === "number" && this.minLength >= 0),
            hasName: this.name ? true : false,
            hasTip: this.widgetRenderOptions.renderTips && this.tip,
            hasValue: this.value ? true : false,
            id: this.id,
            inputClass: this.globalClasses.input ?? "",
            inputIdDesign: inputIdDesign,
            inputIdRun: inputIdRun,
            label: this.label,
            mark: this.requiredAttributeSettings.mark,
            maxLength: this.maxLength,
            minLength: this.minLength,
            mode: constants.WIDGET_MODE_DESIGN,
            labelClass: this.globalClasses.label ?? "",
            required: this.required,
            showGrip: this.widgetRenderOptions.renderGrip,
            showRemove: this.widgetRenderOptions.renderRemove,
            showRequiredMarkAfter: this.required && this.requiredAttributeSettings.mark && this.requiredAttributeSettings.position == constants.WIDGET_LABEL_REQUIRED_MARK_POSITION_AFTER,
            showRequiredMarkBefore: this.required && this.requiredAttributeSettings.mark && this.requiredAttributeSettings.position == constants.WIDGET_LABEL_REQUIRED_MARK_POSITION_BEFORE,
            spanClass: this.globalClasses.span ?? "",
            style: this.height ? `height: ${this.height}` : "",
            type: this.type,
            value: this.value,
            widgetClass: widgetClass,
            widgetPropertiesButtonTitle: Strings.WidgetPropertiesButtonTitle,
            widgetRemoveButtonTitle: Strings.WidgetRemoveButtonTitle,
        };

        var html = await super._loadWidgetTemplate("widget-text", replacements);
        super._renderDOM(container, parser, html);
    }

    get value() { return super.value; }
    set value(value) {
        super.value = value;
    }

    validate(validationOptions) {
        this.clearError();
        var input = this._el.querySelector(`[data-show-when="run"] input`);
        var r = super._validateInputCtl(input);

        // if base validation ok, validate text-specific properties
        if (r.result) {
            if (input.value) {
                if (this.minLength && input.value.length < this.minLength)
                    r = { result: false, message: this.minLengthValidationMessage };
                else if (this.maxLength && input.value.length > this.maxLength)
                    r = { result: false, message: this.maxLengthValidationMessage };
                else if (this.pattern && !this.pattern.regex.test(input.value))
                    r = { result: false, message: this.patternValidationMessage };
            }
        }

        if (validationOptions && validationOptions.showErrors && !r.result)
            this.setError(r);
        return r;
    }
}

export default WidgetText;